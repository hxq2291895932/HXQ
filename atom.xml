<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>umzhaa‘website</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://umzhaa.website/"/>
  <updated>2019-12-21T15:08:50.483Z</updated>
  <id>http://umzhaa.website/</id>
  
  <author>
    <name>umzhaa</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PCA相关总结</title>
    <link href="http://umzhaa.website/2019/12/21/PCA%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
    <id>http://umzhaa.website/2019/12/21/PCA%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</id>
    <published>2019-12-21T14:36:50.000Z</published>
    <updated>2019-12-21T15:08:50.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是PCA？"><a href="#什么是PCA？" class="headerlink" title="什么是PCA？"></a>什么是PCA？</h1><blockquote><p>PCA(principal component analysis)，也就是主成分分析，是一种算法，主要用来数据降维。</p><p>PCA是将原始的样本矩阵$X$转换成降维后的新样本$Y$的一种方法。</p><p>为了实现维度变化我们需要一个</p><p>变换矩阵$U$，$Y_{r \times n} = {U^T}_{r \times m}X_{m \times n}$（这里是先转置，再取前n行），用于对行进行压缩</p><p>或者矩阵$V$，${Y_{m \times r}} = {X_{m \times n}}{V_{n \times r}}$，用于对列进行压缩。</p><p>一般不会对样本数量降维，都是对样本的特征数量降维，也就是用少量的特征数量去表征样本的特征，这样就实现了数据降维。</p></blockquote><h1 id="怎么计算PCA？"><a href="#怎么计算PCA？" class="headerlink" title="怎么计算PCA？"></a>怎么计算PCA？</h1><p>PCA计算一般有两种常用的方法，分别是特征值分解法和奇异值分解法。</p><h2 id="特征值分解："><a href="#特征值分解：" class="headerlink" title="特征值分解："></a>特征值分解：</h2><h3 id="推导："><a href="#推导：" class="headerlink" title="推导："></a>推导：</h3><blockquote><p>PCA是要求降维后的数据$Y$的方差最大，并且基向量之间正交。</p><p>数据的方差计算公式：</p><script type="math/tex; mode=display">\frac{1}NaN\sum\limits_{i = 1}^n  {\left ( {U_i^{T}{X_i} - U_i^T\mu } \right )}^2 = \frac{1}NaN\sum\limits_{i = 1}^n {U_i^T \cdot X'X{'^T} \cdot {U_i}}</script><p>其中的$S = {X^{‘}}{X^{‘T}}$就是为$X^{‘}$的协方差矩阵，而$\mu$表示样本的平均值。</p><p>注意其中$U$是正交矩阵，也就是<script type="math/tex">{U^T}U = I</script>，并且协方差矩阵的特征值和特征向量满足：</p><p><script type="math/tex">S{U_i} = \lambda {U_i}</script>，也就是$U_i^TS{U_i}{\text{ = }}\lambda_i $，代入上面式子，方差计算最后的结果就是<script type="math/tex">\frac{1}NaN\sum\limits_{i = 1}^n {\lambda_i}</script>。</p><p>所以，选择特征值越大的特征向量，越能代表数据的原始特征。</p></blockquote><h3 id="计算步骤（并不是代码，简单表明一下计算步骤）："><a href="#计算步骤（并不是代码，简单表明一下计算步骤）：" class="headerlink" title="计算步骤（并不是代码，简单表明一下计算步骤）："></a>计算步骤（并不是代码，简单表明一下计算步骤）：</h3><ul><li>样本均值化：$X’=X-\mu$</li><li>计算协方差矩阵：$S=X’X{‘^T}$或者$S’=X{‘^T}X’$</li><li>计算协方差矩阵的特征值和特征向量：$\lambda,V=eig(S’)$或者 $\lambda,U=eig(S)$</li><li>最后计算降维后的数据：<script type="math/tex">{Y_{m \times r}} = {X_{m \times n}}{V_{n \times r}}</script>或者${Y_{r \times n}} = {U^T}_{r \times m}{X_{m \times n}}$</li></ul><h2 id="奇异值分解，SVD，Singular-value-decomposition"><a href="#奇异值分解，SVD，Singular-value-decomposition" class="headerlink" title="奇异值分解，SVD，Singular value decomposition"></a>奇异值分解，SVD，Singular value decomposition</h2><h3 id="为什么要用奇异值分解？"><a href="#为什么要用奇异值分解？" class="headerlink" title="为什么要用奇异值分解？"></a>为什么要用奇异值分解？</h3><blockquote><p>其实从上面也可以看出来，特征值分解的方法虽然不难，但是计算起来比较耗费时间。</p><p>而SVD分解的方法也可以计算$U$和$V$并且有些情况下会更快。所以说，SVD可以实现PCA。不要把他们两个弄混了。</p></blockquote><h3 id="奇异值分解原理："><a href="#奇异值分解原理：" class="headerlink" title="奇异值分解原理："></a>奇异值分解原理：</h3><blockquote><p>其实奇异值分解的原始计算方法还是利用特征值分解，具体方法如下：</p><ul><li>首先一个矩阵可以分解成这种形式：$X_{m\times n}=U_{m\times m}\Sigma_{m\times n} V^{T}_{n\times n}$（证明略）</li><li>所以其协方差矩阵就是<script type="math/tex">X{X'} = U{\Sigma _1}{V^T}V{\Sigma _1}^T{U^T} = U{\Sigma _1}{\Sigma _1}^T{U^T} = U\Sigma {U^T}</script>，这里加了下标的就是前面的那个$\Sigma $矩阵，没加下标的矩阵是另一个矩阵，以示区别。</li><li>所以$U$就是协方差矩阵$S$的特征向量构成的矩阵，当然$V$也是$S^{‘}$的特征向量构成的矩阵</li><li>对$S$和$S’$进行特征值分解就可以得到$U$和$V$。</li><li>$\Sigma $是一个对角矩阵，主对角元素是奇异值，一般从大到小排列，我们只需要用得到的特征值这样<script type="math/tex">\sigma _i = \sqrt \lambda _i</script>就可以得到奇异值矩阵$\Sigma $</li></ul></blockquote><h3 id="有同学可能会问了，这不就是特征值分解的步骤吗，你这不就又回去了吗？"><a href="#有同学可能会问了，这不就是特征值分解的步骤吗，你这不就又回去了吗？" class="headerlink" title="有同学可能会问了，这不就是特征值分解的步骤吗，你这不就又回去了吗？"></a>有同学可能会问了，这不就是特征值分解的步骤吗，你这不就又回去了吗？</h3><blockquote><ul><li>没错，奇异值分解的步骤就是这样子，那为什么我们还用奇异值分解呢？</li><li>这是因为在实际计算的时候，像一些框架，比如numpy会有特殊的算法来计算奇异值分解而不用上面那个步骤，并且速度会更快，所以使用SVD可以提高PCA的步骤。</li><li><font color=gray><b>如果要自己实现的话还是使用特征值分解的方法吧，毕竟咱也没什么快速计算SVD的方法，折腾一圈算法会更慢。</b></font></li></ul></blockquote><h3 id="那么使用奇异值分解来计算PCA的步骤是："><a href="#那么使用奇异值分解来计算PCA的步骤是：" class="headerlink" title="那么使用奇异值分解来计算PCA的步骤是："></a>那么使用奇异值分解来计算PCA的步骤是：</h3><ul><li>$X=U\Sigma V^{T}$（这里我觉得应该要先对$X$做均值化操作，网上查了查没有找到，希望大佬解答疑惑）</li><li><script type="math/tex">{Y_{m \times r}} = {X_{m \times n}}{V_{n \times r}}</script>或者${Y_{r \times n}} = {U^T}_{r \times m}{X_{m \times n}}$</li><li>是不是感觉特别简单了呢？？</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>花了一晚上来写，主要是公式有点多，写的也不是很熟练。我也是网上查别人的博客结合个人理解总结的，如有不对请在下面评论指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是PCA？&quot;&gt;&lt;a href=&quot;#什么是PCA？&quot; class=&quot;headerlink&quot; title=&quot;什么是PCA？&quot;&gt;&lt;/a&gt;什么是PCA？&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;PCA(principal component analysis)，也就是
      
    
    </summary>
    
    
    
      <category term="教程" scheme="http://umzhaa.website/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="deep learning" scheme="http://umzhaa.website/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>语义相似性分析大数据比赛总结</title>
    <link href="http://umzhaa.website/2019/12/15/%E8%AF%AD%E4%B9%89%E7%9B%B8%E4%BC%BC%E6%80%A7%E5%88%86%E6%9E%90%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://umzhaa.website/2019/12/15/%E8%AF%AD%E4%B9%89%E7%9B%B8%E4%BC%BC%E6%80%A7%E5%88%86%E6%9E%90%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/</id>
    <published>2019-12-15T04:21:31.194Z</published>
    <updated>2019-12-15T04:33:41.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="所用方法"><a href="#所用方法" class="headerlink" title="所用方法"></a>所用方法</h1><p>KNN、MLP、BP神经网络、RNN（LSTM）</p><h1 id="所用框架"><a href="#所用框架" class="headerlink" title="所用框架"></a>所用框架</h1><p>numpy、pandas、jieba、os、gensim（Word2Vec、Doc2Vec）、pytorch</p><h1 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h1><ul><li><p>numpy用于处理数据矩阵，进行一些运算和操作</p></li><li><p>pandas用于读取训练集和测试集的csv文件</p></li><li><p>os主要用来操做文件的复制和移动</p></li><li><p>gensim主要用Word2Vec框架来将语言转化成词向量（非one-hot形式，词向量加权平均得到句子向量）或者直接用Doc2Vec得到句向量（效果不如先用词向量好）</p></li><li><p>jieba主要用来分词</p></li><li><p>pytorch主要用来构建自己的神经网络模型</p></li></ul><h1 id="总结一下一般做这些比赛的流程："><a href="#总结一下一般做这些比赛的流程：" class="headerlink" title="总结一下一般做这些比赛的流程："></a>总结一下一般做这些比赛的流程：</h1><ol><li><p>对问题进行归类：是regression（回归）还是classifier（分类），如果是分类是二分类还是多分类。</p></li><li><p>对训练集进行分类，根据有无label分为有监督和无监督，一般我们做的都是有监督的问题。</p></li><li><p>选择相应的算法，比如一些基础的：KNN、MLP、Logistic、Linear，得到baseline，在进行扩充。可参考sklearn给出的官方图片。</p><p><img alt="img" data-src="https://img-blog.csdn.net/20170413180901319?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWltaW5nc2lsZW5jZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" class="lazyload"></p></li><li><p>对训练集进行预处理，比如分词，转化成向量或者矩阵，训练语言模型，进行归一化等处理</p></li><li><p>划分训练集和测试集：如果样本较少，可以按照7：3，如果样本较多，可以8：2，9：1等。</p></li><li><p>选定loss函数，常见的有均方根误差、交叉验证误差等</p></li><li><p>输入模型进行训练，对划分出来的测试集进行预测或者分类</p></li><li><p>计算准确（accuracy）率、召回（recall）率，得到f1-score（值越大表示模型越准确），据此对模型进行改进</p></li><li><p>看是否模型有过拟合、欠拟合的现象，对模型进行改进，也就是所谓的调参</p></li><li><p>欠拟合：增加训练集（网上寻找或者人工生成），增大模型的layer层数或者添加bias，减小学习率，增大学习次数等</p></li><li><p>过拟合：增加正则化项、调整batch size等</p></li><li><p>在开发集上进行预测或者分类   </p></li></ol><h1 id="另外附上一些入门和参考的资料："><a href="#另外附上一些入门和参考的资料：" class="headerlink" title="另外附上一些入门和参考的资料："></a>另外附上一些入门和参考的资料：</h1><ul><li><p><strong>入门</strong>：吴恩达（Andrew Ng）的机器学习系列视频：</p><p>​    coursera源地址：<a href="https://www.coursera.org/learn/machine-learning?" target="_blank" rel="noopener">https://www.coursera.org/learn/machine-learning?</a></p><p>​    B站转载：<a href="https://b23.tv/av9912938/p1" target="_blank" rel="noopener">https://b23.tv/av9912938/p1</a></p></li><li><p><strong>进阶</strong>：吴恩达的深度学习系列视频：</p><p>​    coursera源地址：<a href="https://www.coursera.org/specializations/deep-learning?" target="_blank" rel="noopener">https://www.coursera.org/specializations/deep-learning?</a></p><p>​    B站转载：<a href="https://b23.tv/av43550001/p1" target="_blank" rel="noopener">https://b23.tv/av43550001/p1</a></p></li><li><p><strong>os、numpy和pandas：</strong>可以参考官方文档，也可以看一些博客和菜鸟教程：<a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com</a>，内容都差不多</p></li><li><p><strong>jieba使用可参考这篇博客：</strong><a href="https://www.cnblogs.com/xiaoyh/p/9919590.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoyh/p/9919590.html</a>，用到的功能不是很多，简单了解</p></li><li><p><strong>Word2Vec</strong>可参考这篇文章：<a href="https://www.jianshu.com/p/ce630c198762" target="_blank" rel="noopener">https://www.jianshu.com/p/ce630c198762</a></p></li><li><p><strong>Doc2Vec</strong>可参考这篇文章：<a href="https://www.jianshu.com/p/854a59b93e09" target="_blank" rel="noopener">https://www.jianshu.com/p/854a59b93e09</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;所用方法&quot;&gt;&lt;a href=&quot;#所用方法&quot; class=&quot;headerlink&quot; title=&quot;所用方法&quot;&gt;&lt;/a&gt;所用方法&lt;/h1&gt;&lt;p&gt;KNN、MLP、BP神经网络、RNN（LSTM）&lt;/p&gt;
&lt;h1 id=&quot;所用框架&quot;&gt;&lt;a href=&quot;#所用框架&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>&#39;关于建blog过程和踩过的坑&#39;</title>
    <link href="http://umzhaa.website/2019/12/12/%E5%85%B3%E4%BA%8E%E5%BB%BAblog%E8%BF%87%E7%A8%8B%E5%92%8C%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    <id>http://umzhaa.website/2019/12/12/%E5%85%B3%E4%BA%8E%E5%BB%BAblog%E8%BF%87%E7%A8%8B%E5%92%8C%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</id>
    <published>2019-12-12T15:55:49.000Z</published>
    <updated>2019-12-21T14:29:56.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于建blog过程和踩过的坑"><a href="#关于建blog过程和踩过的坑" class="headerlink" title="关于建blog过程和踩过的坑"></a>关于建blog过程和踩过的坑</h1><p><em>写在前面：一个电脑新手，这是我第一次写博客，参考的教程来自15级的一个学长，基本就是根据他建立的过程来操作的</em></p><h2 id="主要步骤："><a href="#主要步骤：" class="headerlink" title="主要步骤："></a>主要步骤：</h2><ul><li><font face="微软雅黑" size=3>注册github账户，新开一个repository，设置git page  也可以租一个VPS，<del>但是免费的git page托管服务多好用啊</del></font></li><li><font face="微软雅黑" size=3>下载安装hexo，跟着教程来操作就OK了</font>  </li><li><font face="微软雅黑" size=3>可以再hexo设置自己喜欢的主题和插件</font></li><li><font face="微软雅黑" size=3>最后托管到github上面</font>> <font face="微软雅黑" size=3>其实用这个的另一个原因是我想学一学markdown，之前有看过这个，感觉用起来还不错，语法也和html基本上差不多<del>关键是jupyter notebook也支持</del>(。・∀・)ノ</font></li></ul><p>嘿嘿(～﹃～)~zZ，先写这么多，踩过的坑有点多，一时间写不完。</p><h2 id="遇到的坑（或者比较难的地方吧）："><a href="#遇到的坑（或者比较难的地方吧）：" class="headerlink" title="遇到的坑（或者比较难的地方吧）："></a>遇到的坑（或者比较难的地方吧）：</h2><blockquote><p>注意，下面所有带[]的表示里面的内容需要根据自己的进行替换，并没有什么其他的意思  </p></blockquote><p>绑定github账户</p><blockquote><p>这部分其实还好，也就是git的使用，baidu教程一大堆，常用的也就那几个</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git init  #初始化本地git仓库</span><br><span class="line">git add filename #添加文件到缓冲区</span><br><span class="line">git commit -m &quot;提交的说明&quot; #提交文件更新</span><br><span class="line">git status  #查看git库的状态</span><br><span class="line">git remote add origin [远端仓库地址] #这样就增加了远程仓库</span><br><span class="line">git push origin master #push到origin仓库的master分支</span><br><span class="line">git push [仓库地址] master #push到仓库master分支</span><br><span class="line">git pull # 拉取远端仓库到本地，如果push有问题，就要先pull，解决冲突，然后再push</span><br><span class="line">git config --global user.name &quot;[你的名字]&quot; #这里用来作为github收到的提交的用户名</span><br><span class="line">git config --global user.name &quot;[你的邮箱]&quot; #和上面作用相同</span><br><span class="line">ssh-keygen  #生成公钥和私钥，用来连接github</span><br></pre></td></tr></table></figure><p>购买域名（VPS）</p><blockquote><ul><li>我是在Gandi.net上面买的，感觉还比较便宜。因为大天朝还需要备案，总感觉不太方便，所以就在国外买了，Godaddy也不错听说也不错，但是我注册一直不成功，就换成这个了，目前买的是每年7RMB。  </li><li>Gandi还可以添加网页转址，所以直接将网页转向github的二级域名username.github.io也能用，但是那就没有买域名的意义了。  </li><li>然后就是添加DNS，Gandi提供免费的DNS，但是国外的毕竟速度不如国内，所以用国内的DNSPod，要在Gandi那里改DNS服务器，在DNSPod加上要解析的域名地址，在控制台加上@ A [git pages的IP地址]、WWW CNAME [你的域名]记录。</li><li>最后在本地新建一个CNAME文件，文件内容是你的域名，放到source文件夹下，因为hexo每次clean会将非generate生成的文件清除，而放到source文件夹下不会被清除。</li></ul></blockquote><p>_config.yml的配置<br>我觉得<text style="color:red">最难</text>的一步是URL和ROOT的设置，经常出错。</p><blockquote><ul><li>一开始我的域名是”[username].github.io/[sample]”。<br>那么URL要设置成”[username].github.io/[sample]”，而ROOT要设置成”/[sample]/“（注意’/‘号）</li><li>后来我的域名换成了”umzhaa.website”，也就是现在这个<br>那么我的URL就要设置成”umzhaa.website”，ROOT设置成”/“</li></ul></blockquote><p>添加看板娘</p><blockquote><p>hexo是有自带的看板娘插件的  </p></blockquote><p><code>npm install --save hexo-helper-live2d</code></p><blockquote><p>安装的插件后修改_config.yml，在里面添加</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Live2D</span><br><span class="line">## https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2d</span><br><span class="line">live2d:</span><br><span class="line">  enable: true # 开启live2d</span><br><span class="line">  # enable: false</span><br><span class="line">  scriptFrom: local # 默认</span><br><span class="line">  pluginRootPath: live2dw&#x2F; # 插件在站点上的根目录(相对路径)</span><br><span class="line">  pluginJsPath: lib&#x2F; # 脚本文件相对与插件根目录路径</span><br><span class="line">  pluginModelPath: assets&#x2F; # 模型文件相对与插件根目录路径</span><br><span class="line">  # scriptFrom: jsdelivr # jsdelivr CDN</span><br><span class="line">  # scriptFrom: unpkg # unpkg CDN</span><br><span class="line">  # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 你的自定义 url</span><br><span class="line">  tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br><span class="line">  debug: false # 调试, 是否在控制台输出日志</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko # npm-module package name</span><br><span class="line">    # use: wanko # 博客根目录&#x2F;live2d_models&#x2F; 下的目录名</span><br><span class="line">    # use: .&#x2F;wives&#x2F;wanko # 相对于博客根目录的路径</span><br><span class="line">    # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 你的自定义 url</span><br></pre></td></tr></table></figure><font face="微软雅黑" style="color:blue;" size=4>有关其他模型的下载</font>  <font size=3.5>使用自己下载的模型</font>  <p>方式一（推荐使用）：</p><ul><li>在您博客根目录下创建一个 live2d_models 文件夹</li><li>在此文件夹内新建一个子文件夹</li><li>将你的 Live2D 模型复制到这个子文件夹中，自有模型应当有一个 .model.json 文件 (例如 mymiku.model.json)</li><li>将子文件夹的名称输入 _config.yml 的 model.use 中</li></ul><p>方式二：</p><ul><li>您可直接输入相对于博客根目录的自定义路径到 model.use中,示例: ./wives/wanko</li></ul><p><font size=3.5>使用 npm 下载的模型</font><br>方式一：  </p><p>下载现有的 npm 资源</p><ul><li>官方提供了多款精美的模型，<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">模型预览</a></li><li>你需要先使用 npm install 模型的包名 来安装，然后将包名输入位于 _config.yml 的 model.use 中</li></ul><p>方式二：</p><ul><li>发布你自己的模型包</li><li>新建一个目录, 用你的 Node 环境执行 npm init，我们推荐您使用 live2d-widget-model-xxx 的包名<br>再使用方式一来使用自己的模型</li></ul><p>先写这么多吧，以后如果有什么要补充的再更新吧，如果没有的话可能就要开新坑了</p><p>2019年12月21日</p><h2 id="显示公式"><a href="#显示公式" class="headerlink" title="显示公式"></a>显示公式</h2><p>首先切换渲染引擎：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><p>然后更改配置文件<code>/node_modules/hexo-renderer-kramed/lib/renderer.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Fit kramed's rule: $$ + \1 + $$</span></span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="regexp">/`\$(.*?)\$`/g</span>, <span class="string">'$$$$$1$$$$'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change inline math rule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>停止使用hexo-math，安装mathjax包。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure><p>安装hexo-renderer-mathjax包</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure><p>更新mathjax配置文件</p><p>打开<code>/node_modules/hexo-renderer-mathjax/mathjax.html</code><br>更改为：</p><p><code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;</code></p><p>因为LaTeX与markdown语法有语义冲突，所以 hexo 默认的转义规则会将一些字符进行转义，所以我们需要对默认的规则进行修改.</p><p> 打开<code>/node_modules\kramed\lib\rules\inline.js</code><br> 1、</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><p>更改为</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([`*\[\]()# +\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><p>2、</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">em:</span> /^\b<span class="number">_</span>((<span class="string">?:</span>_<span class="number">_</span><span class="params">|[\s\S])+?)_\b|</span>^\*((?<span class="symbol">:</span>\*\*<span class="params">|[\s\S])+?)\*(?!\*)/,</span></span><br></pre></td></tr></table></figure><p>更改为</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><p>开启mathjax</p><p>打开<code>/themes/yilia</code>主题目录下的<code>config.yml</code>文件<br> 因为我用的<code>yilia</code>主题，所以路径是<code>/themes/yilia</code></p><p>我们需要在<code>config.yml</code>文件 中开启 Mathjax， 找到 mathjax 字段添加如下代码：(不同的主题配置方法略微有区别)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mathjax:</span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathjax: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>写博客文件时要添加mathjax内容。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">title</span>: 特征提取——局部特征</span><br><span class="line"><span class="selector-tag">date</span>: 2018<span class="selector-tag">-07-16</span> 09<span class="selector-pseudo">:39</span><span class="selector-pseudo">:40</span></span><br><span class="line"><span class="selector-tag">tags</span>: <span class="selector-attr">[GitHub, Mysql]</span></span><br><span class="line"><span class="selector-tag">mathjax</span>: <span class="selector-tag">true</span></span><br></pre></td></tr></table></figure><p>来源于简书：<a href="https://www.jianshu.com/p/68e6f82d88b7" target="_blank" rel="noopener">https://www.jianshu.com/p/68e6f82d88b7</a></p><p>作者：AomanHao</p>]]></content>
    
    <summary type="html">
    
      [object Object]
    
    </summary>
    
    
    
      <category term="博客" scheme="http://umzhaa.website/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="教程" scheme="http://umzhaa.website/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
